const express = require('express');
const { ethers } = require('ethers');
const cors = require('cors');
require('dotenv').config();

const app = express();
app.use(cors());
app.use(express.json());

// === CONFIGURATION (MUST SET THESE) ===
const CONTRACT_ADDRESS = process.env.CONTRACT_ADDRESS; // Deployed contract address
const CONTRACT_ABI = require('./RecoveryEscrowABI.json'); // You will get this after compiling the contract
const RPC_URL = process.env.RPC_URL || "https://sepolia.infura.io/v3/YOUR_PROJECT_ID";
const PRIVATE_KEY = process.env.PRIVATE_KEY; // Your backend wallet's private key (for admin tasks)

// Initialize provider, signer, and contract
const provider = new ethers.JsonRpcProvider(RPC_URL);
const signer = new ethers.Wallet(PRIVATE_KEY, provider);
const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

// API Endpoint: Get all agreement IDs for a user (client or service)
app.get('/api/agreements/:address', async (req, res) => {
    try {
        const userAddress = req.params.address;
        const totalAgreements = await contract.getAgreementCount();
        const userAgreements = [];

        for (let i = 0; i < totalAgreements; i++) {
            const agreement = await contract.getAgreement(i);
            // If the user is either the depositor or beneficiary of this agreement
            if (agreement.depositor.toLowerCase() === userAddress.toLowerCase() || 
                agreement.beneficiary.toLowerCase() === userAddress.toLowerCase()) {
                userAgreements.push({
                    id: i,
                    ...agreement
                });
            }
        }
        res.json({ agreements: userAgreements });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Failed to fetch agreements' });
    }
});

// API Endpoint: Simulate the delivery of a recovery report (stores IPFS hash)
app.post('/api/deliver-report', async (req, res) => {
    // In reality, you would:
    // 1. Upload the PDF report to IPFS (using a service like Pinata)
    // 2. Get back the IPFS hash (e.g., "QmXyz...")
    // 3. Call the smart contract's fulfillService function with that hash

    const { agreementId, ipfsHash } = req.body;
    
    try {
        const tx = await contract.fulfillService(agreementId, ipfsHash);
        await tx.wait(); // Wait for blockchain confirmation
        res.json({ success: true, transactionHash: tx.hash, message: 'Report delivered and payment released.' });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Failed to deliver report' });
    }
});

// API Endpoint: Get contract details for the frontend
app.get('/api/contract-info', (req, res) => {
    res.json({
        address: CONTRACT_ADDRESS,
        network: RPC_URL.includes('sepolia') ? 'Sepolia Testnet' : 'Mainnet'
    });
});

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
    console.log(`Backend server running on port ${PORT}`);
});
